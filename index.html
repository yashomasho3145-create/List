/* ======== タッチ専用：☰ハンドルで並び替え ======== */
(function enableTouchReorder(){
  const lists = document.querySelectorAll('.list');

  let dragging = null;   // { card, startY, lastY, placeholder, fromList, offsetY }
  let autoScrollRAF = null;

  // 各カード生成時に .handle を右端に入れているので、委譲で拾う
  document.addEventListener('touchstart', (e) => {
    const handle = e.target.closest('.handle');
    if (!handle) return;
    const card = handle.closest('.card');
    if (!card) return;

    const rect = card.getBoundingClientRect();
    const ph = document.createElement('div');
    ph.className = 'card placeholder';
    ph.style.height = rect.height + 'px'; // 高さをカードに合わせる

    const fromList = card.parentElement;   // pinned/active/completed のいずれか
    card.classList.add('dragging');
    card.style.width = rect.width + 'px';
    card.style.position = 'fixed';
    card.style.left = rect.left + 'px';
    card.style.top = rect.top + 'px';
    card.style.zIndex = '999';

    // 元の位置にプレースホルダを差し込む
    fromList.insertBefore(ph, card.nextSibling);

    dragging = {
      card, placeholder: ph, fromList,
      startY: e.touches[0].clientY,
      lastY:  e.touches[0].clientY,
      offsetY: e.touches[0].clientY - rect.top
    };

    // スクロール抑止（横持ちでも安定させたいので）
    e.preventDefault();
  }, { passive: false });

  document.addEventListener('touchmove', (e) => {
    if (!dragging) return;

    const y = e.touches[0].clientY;
    dragging.lastY = y;

    // カードを指に追従
    const top = y - dragging.offsetY;
    dragging.card.style.top = `${top}px`;

    // どのリスト上か判定
    const el = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
    const list = el ? el.closest('.list') : null;

    if (list) {
      // 同一リスト内の挿入位置を見つける
      const siblings = [...list.querySelectorAll('.card:not(.dragging)')];
      let placed = false;
      for (const sib of siblings) {
        const r = sib.getBoundingClientRect();
        // カードの中心が sib の上半分に入ったら、その前に置く
        if (y < r.top + r.height / 2) {
          list.insertBefore(dragging.placeholder, sib);
          placed = true;
          break;
        }
      }
      if (!placed) {
        list.appendChild(dragging.placeholder);
      }
    }

    // 画面端でのオートスクロール
    maybeAutoScroll();

    e.preventDefault();
  }, { passive: false });

  document.addEventListener('touchend', () => {
    if (!dragging) return;
    cancelAutoScroll();

    const { card, placeholder } = dragging;

    // プレースホルダ位置に確定
    placeholder.parentElement.insertBefore(card, placeholder);
    placeholder.remove();

    // スタイル後始末
    card.classList.remove('dragging');
    card.style.position = '';
    card.style.left = '';
    card.style.top = '';
    card.style.width = '';
    card.style.zIndex = '';

    // ここで順序の保存APIを呼ぶ場合は、list内の並びを読み取って送信する
    // saveOrderIfNeeded(placeholder.parentElement);

    dragging = null;
  });

  function maybeAutoScroll(){
    if (autoScrollRAF) return;
    const margin = 60; // 端からこのピクセルでオートスクロール
    const speed  = 12; // スクロール速度(px/frame)

    const step = () => {
      if (!dragging) { autoScrollRAF = null; return; }
      const y = dragging.lastY;
      const vh = window.innerHeight;

      if (y < margin) {
        window.scrollBy(0, -speed);
      } else if (y > vh - margin) {
        window.scrollBy(0, speed);
      }
      autoScrollRAF = requestAnimationFrame(step);
    };
    autoScrollRAF = requestAnimationFrame(step);
  }

  function cancelAutoScroll(){
    if (autoScrollRAF) cancelAnimationFrame(autoScrollRAF);
    autoScrollRAF = null;
  }

  // 並び順を保存したいときの例（必要なら使って）
  async function saveOrderIfNeeded(listEl){
    const listId = listEl.id; // 'pinned'|'active'|'completed'
    const order = [...listEl.querySelectorAll('.card')].map((c, idx) => {
      // t.id を data-id に入れてある場合
      return { task_id: c.dataset.id, pos: idx };
    });
    // 例:
    // await fetch(`${API_BASE}/action`, {
    //   method: 'POST',
    //   headers: { 'Content-Type':'application/json' },
    //   body: JSON.stringify({ user_id: userId, action:'reorder', list: listId, order })
    // });
  }
})();
